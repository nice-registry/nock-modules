{"name":"rrm","version":"0.1.2","description":"A non-relational \"ORM\" that sits atop Riak.","main":"lib/rrm.js","scripts":{"test":"mocha"},"repository":"https://github.com/janearc/rrm","keywords":["riak","synchronous","simple","promises","q","orm","object","relational","model","sendak"],"license":"CC0-1.0","dependencies":{"riak-dc":">=0.2.8","mocha":"*","nock":"*","log4js":"*","deep-grep":">=0.3.5","chai":"*","q":"*","chai-as-promised":"*","sendak-usage":">=0.0.6","moment":">=2.0.0"},"homepage":"https://github.com/janearc/rrm","gitHead":"86eb209822692f2cd9ff9de951f72683d85a0013","deprecated":"0.1.2","versions":[{"number":"0.0.3","date":"2014-11-07T21:06:35.485Z"},{"number":"0.0.4","date":"2014-12-03T14:50:53.394Z"},{"number":"0.0.6","date":"2015-01-07T02:05:39.770Z"},{"number":"0.1.0","date":"2015-01-22T21:02:01.541Z"},{"number":"0.1.1","date":"2015-02-08T02:21:42.412Z"},{"number":"0.1.2","date":"2015-02-19T23:15:19.481Z"}],"readme":"RRM, an ORM\\* for Riak\n====\n\nSo in the course of building [Sendak](https://github.com/18F/Sendak) for\n[18F](https://18f.gsa.gov/), I wanted to use an ORM. I found that ORMs\nwere very complicated. I found that node itself was kind of poorly-suited\nto the way that ORMs worked. I also found that ORMs (for Javascript)\ngenerally did not provide the functionality I wanted (for example\nkeeping state in the database).\n\nAs I sat down to write my own ORM, I realised that the biggest part of it,\ncode-wise, was going to actually be the SQL layer. As it happens, writing\nSQL parsers, SQL generators, stored procedures, and so forth, while\nmaintaining an agnostic stance towards choice of database (even without this),\nthe task is nothing less than odious, and results in huge code-sprawl, when\nall I wanted was a way to create some simple objects and store them in a\nplace that bunches of things could get to (accordingly, a json file was not\nsufficient), and I didn't want to have to worry about the \"database layer\";\nI wanted objects &mdash; data structures &mdash; that I could read and write\nwithout having data logic in my code.\n\nThere are lots of document-store and key-value store \"databases\" out there.\nFor various reasons, I chose Riak to put this on top of. No more need for\nSQL, native storage of JSON, and it seemed like a win.\n\nRather than use the rather ponderous and somewhat inscrutable [riak-js](http://riakjs.com/),\nI wrote a very tiny library, [riak-dc](https://github.com/janearc/riak-dc), which is\nthe barest of wrappers around node's own [http](http://nodejs.org/api/http.html).\n\nAccordingly, you will find that this library is very tiny, takes up very\nlittle space in terms of lines-of-code, is end-to-end javascript & json, and\nmeets the above requirements:\n\n* No stupid SQL tricks\n* JSON object storage\n* Schema stored in the database\n* Exceedingly simple API\n* No pyramid of fail\n\n\\* note: RRM is not actually \"relational.\"\n\nHow to use RRM\n====\n\nBasically, `npm install rrm` should do the trick and install dependencies.\nUnit tests are mocked, but you will need a Riak somewhere to talk to. `riak-dc`\nassumes that you are using `http://localhost:8098/riak`, and if you are, RRM\nrequires no configuration. If not, be sure to initialise `riak-dc` before\nusing RRM.\n\n#### Key concepts:\n\nRRM stores a 'schema' in Riak, from which it derives prototypes of each of the\nobject types stored in the RRM. The schema is not actually \"bound\" to\nanything, as such, and serves only as a template from which to build new\nobjects.\n\nThese objects are stored in a Riak bucket according to their prototype (so all\nthe 'automobile' objects are stored in `riak/automobile/{serial}`.\n\nObjects are \"anonymous\" until they are stored in Riak, which gives them a\nunique serial (for SQL people, you might call this a 'primary key').\n\nObjects also contain no metadata about what they are. So you must keep track\nof which type of object you have. RRM is flexible enough that if you wanted to\nincorporate a `typeof` attribute, you could do this, but you would have to\nkeep track of that yourself.\n\nThere is no strict checking for whether an object you are storing actually\nconforms to the schema.\n\n#### Exported functions:\n\nUnless otherwise specified, all references to returned values are actually\npromises (using `q`, rather than the value itself). So \"returns a hash\" means\n\"returns a promise to a hash.\"\n\n* `add_object( type, object )`\n\nTakes two arguments, the type of object being added and an anonymous object to\nbe added. Note that if this object is already in Riak, an Error will be\nreturned. For existing objects, use `update_object`.\n\n* `del_object( type, object )`\n\nTakes two arguments, the type of object to be deleted from Riak and the object\nitself. This object must have a serial, or an exception will be thrown.\n\n* `get_objects( type )`\n\nTakes one argument, the type of objects requested. This returns *all* the\nobjects of that type in Riak. This is actually a very fast operation in Riak\nat most practical scales.\n\nBecause Riak allows the storage of zero-byte tuples, it is possible to store\nan object in Riak which is defined but null. In the event this happens, you\nwill receive an Error instead of the object (rather than not returning or\nreturning the empty list or similar).\n\n* `get_schema( )`\n\nReturns a hash of what the objects look like in Riak. This includes metadata\nand should not be used to \"create new objects\" (see `new_object`). Takes no\narguments.\n\n* `new_object( type )`\n\nTakes object type as sole argument, and returns a new object with relevant\nattributes from the schema. This will not be stored until `add_object` is\ncalled.\n\n* `object_types( )`\n\nTakes no arguments and returns a list of object types defined in the schema.\n\n* `update_object( type, object )`\n\nProvided a type and object, RRM will attempt to find the object in Riak,\n*delete* that object, and re-insert, providing you with a new copy of your\nobject with appropriate serial. Note that deleted objects are\n[tricky](http://docs.basho.com/riak/latest/ops/advanced/deletion/#Tombstones)\nin Riak, so be sparing about the this operation (delete & insert).\n\n#### The basic design pattern\n\n```\nvar rrm     = require( 'rrm' )\n\t, types   = rrm.object_types()\n\t, schema  = rrm.get_schema()\n\t, banana  = rrm.new_object( 'fruit' );\n\nbanana['color'] = 'green';\n\nvar pbanana = rrm.add_object( banana ).then( function (b) {\n\t// 'pbanana' infers 'promise to a banana'\n\t//\n\t// the banana object now has a serial and can be referenced in Riak.\n\tbanana = b;\n\n\t// Time elapses...\n\n\tbanana['color'] = 'yellow';\n\n\tvar promise = rrm.update_object( 'fruit', banana );\n\n\tpromise.then( function (b) {\n\t\t// What will you do with your now-yellow banana?\n\t\t//\n\t\tbanana = b;\n\n\t\t// Time elapses...\n\n\t\t// This will not return anything meaningful, although an error will be\n\t\t// returned if the serial for this banana is not found.\n\t\t//\n\t\trrm.del_object( 'fruit', banana ).then( function (e) {\n\t\t\tif (typeof e == 'error') {\n\t\t\t\tconsole.log( e )\n\t\t\t}\n\t\t} );\n\t} );\n\n} );\n```\n\nWhat's in the box\n====\n\nThere are two tools in the `bin` directory, `rrm.js` and `backupdb.js`.\n\n* `rrm.js` is a simple command-line tool to interface with the rrm. For\nexample, `--get-schema` will return the schema as it appears in Riak, and you\ncan use `--add-object --bucket bucketname --tuple base_64_encoded_object` to\nadd elements to the database. And so on.\n\n* `backupdb.js` because Riak is not a relational database, we don't have\nanything analogous to\n[`pg_dumpall`](http://www.postgresql.org/docs/9.3/static/app-pg-dumpall.html),\nand no real formal language in which to dump the database. But it is still\nimportant to have backups in a modern, production environment. So\n`backupdb.js` is a sort of minimum-effort \"store all the things in the\ndatabase on the disk somewhere.\" It can print to stdout for unixy pipey kinds\nof things, take a filename, or an s3 bucket (you will need credentials for\nthis, obviously).\n\nFuture plans\n====\n\nIf you look over the schema in `examples/`, you will notice I have left a\ncouple fields reserved, and have stubs for relational properties. At some\npoint RRM may actually be relational, but it serves my purpose for now.\nAdditionally, Riak supports Javascript, so it should be possible to add\nconstraints to columns (that is, attributes of objects) such as \"only allow\nthis to be a url\" and similar.\n\nDon't mess with those fields.\n\nI'm not going to break compatibility for a long time, though. So, in the event\nthose things are added, it should be transparent.\n\nAuthor\n====\n\n[@janearc](https://github.com/janearc), jane@cpan.org\n","created":"2014-11-07T21:06:35.485Z","modified":"2015-06-26T18:23:57.784Z","lastPublisher":{"name":"avriette","email":"jane@cpan.org"},"owners":[{"name":"janearc","email":"jane@cpan.org"}],"other":{"_attachments":{},"_from":".","_id":"rrm","_npmUser":{"name":"avriette","email":"jane@cpan.org"},"_npmVersion":"2.0.0-alpha-5","_rev":"1-2cc419733f703b77912b34326b9e2d1c","_shasum":"0bfc405c086017cb3ef3da6fd7e9335240d388de","author":{"name":"Jane Arc","email":"jane@cpan.org","url":"http://github.com/janearc"},"bugs":{"url":"https://github.com/janearc/rrm/issues"},"directories":{"test":"test"},"dist-tags":{"latest":"0.1.2"},"dist":{"shasum":"0bfc405c086017cb3ef3da6fd7e9335240d388de","tarball":"http://registry.npmjs.org/rrm/-/rrm-0.1.2.tgz"},"maintainers":[{"name":"janearc","email":"jane@cpan.org"}],"readmeFilename":"README.md","time":{"modified":"2015-06-26T18:23:57.784Z","created":"2014-11-07T21:06:35.485Z","0.0.3":"2014-11-07T21:06:35.485Z","0.0.4":"2014-12-03T14:50:53.394Z","0.0.6":"2015-01-07T02:05:39.770Z","0.1.0":"2015-01-22T21:02:01.541Z","0.1.1":"2015-02-08T02:21:42.412Z","0.1.2":"2015-02-19T23:15:19.481Z"}}}