{"name":"nock.js","version":"1.1.0","description":"Nock interpreter","main":"nock.js","scripts":{"lint":"standard nock.js test.js","test":"istanbul cover _mocha"},"tonicExampleFilename":"tonic-example.js","license":"MIT","devDependencies":{"chai":"^3.5.0","istanbul":"^0.4.3","mocha":"^2.4.5","standard":"^7.1.1"},"repository":"https://github.com/joemfb/nock.js","keywords":["nock","urbit"],"homepage":"https://github.com/joemfb/nock.js#readme","gitHead":"24cd922aa2c392a732177e5c76cb4103b6055953","versions":[{"number":"1.0.0","date":"2016-04-26T17:48:41.440Z"},{"number":"1.0.1","date":"2016-05-03T04:36:23.983Z"},{"number":"1.0.2","date":"2016-05-03T04:55:04.627Z"},{"number":"1.1.0","date":"2016-06-03T05:40:28.376Z"}],"readme":"### nock.js\n\nNock is a combinator interpreter on nouns. A noun is an atom or a cell.\nAn atom is an unsigned integer of any size; a cell is an ordered pair of nouns.\n\n[Nock](//urbit.org/docs/nock/definition/) is the foundational layer of [Urbit](//urbit.org/posts/overview/).\n\n`nock.js` is a toy interpreter, built for the fun of it.\n\n#### usage\n\n- install from npm: `npm install nock.js`\n\n```js\nvar nock = require('nock.js')\nnock.nock(1, [0, 1])\n// => 1\n```\n\n- or, clone and run\n\n```sh\ngit clone https://github.com/joemfb/nock.js.git\ncd nock.js\nnode example.js\n```\n\n- run unit tests\n\n```sh\nnpm install\nnpm test\n```\n\n- load it in the browser (`nock.js` is a UMD module):\n\n```html\n<script src=\"./nock.js\"></script>\n<script>\n  nock.nock(1, [0, 1])\n  // => 1\n</script>\n```\n\n#### methods\n\n*See [urbit.org/docs/nock/definition/](//urbit.org/docs/nock/definition/) for an explanation of the pseudocode reduction rules that make up the Nock spec.*\n\n##### nock\n\n```\nnock(a)          *a\n[a b c]          [a [b c]]\n*[a [b c] d]     [*[a b c] *[a d]]\n*a               *a\n```\n\n`nock()` recursively applies formulas (tail of its argument) to the subject (head of its argument).\n\n```js\nnock.nock(1, [0, 1])\n// 1\n```\n\nNock nouns are always atoms (unsigned integers) or cells (a pair of nouns). The JS analogue to a cell is `Array(2)`, so `nock()` converts `Array` arguments into nouns, associating right:\n\n```js\nnock.nock([1, 2, 3], [0, 1])\n// [1,[2,3]]\n```\n\nThe subject can be omitted if the formula doesn't reference it:\n\n```js\nnock.nock([1, 1])\n// 1\n```\n\n*Formulas without a subject are evaluated against `[1, 0]`, which is Hoon null (`~`).*\n\nFor convenience in evaluating generated formulas, arguments can be passed as strings (see [**generating formulas**](#generating-formulas) below):\n\n```js\nnock.nock(\"[1 2 3]\", \"[0 1]\")\n// [1,[2,3]]\n```\n\n##### operators\n\nNock defines four operators:\n\n```\n?[a b]           0\n?a               1\n+[a b]           +[a b]\n+a               1 + a\n=[a a]           0\n=[a b]           1\n=a               =a\n\n/[1 a]           a\n/[2 a b]         a\n/[3 a b]         b\n/[(a + a) b]     /[2 /[a b]]\n/[(a + a + 1) b] /[3 /[a b]]\n/a               /a\n```\n\n- *wut* (?): test for an atom (1) or cell (0)\n- *lus* (+): increment an atom\n- *tis* (=): test equality\n- *fas* (/): resolve a tree address\n\n_See [urbit.org/docs/hoon/syntax](//urbit.org/docs/hoon/syntax/#-glyphs-and-characters) for an explanation of the the method names_\n\nOperators are exported in the `nock.operators` namespace:\n\n```js\nnock.operators.fas(2, [5, 9])\n// 5\n```\n\nUnlike `nock()`, operators require both arguments to be present and valid nouns.\n\n##### formulas\n\nNock defines 6 primitive formulas:\n\n```\n*[a 0 b]         /[b a]\n*[a 1 b]         b\n*[a 2 b c]       *[*[a b] *[a c]]\n*[a 3 b]         ?*[a b]\n*[a 4 b]         +*[a b]\n*[a 5 b]         =*[a b]\n```\n\n- *slot* (0): resolve a tree address\n- *constant* (1): return the formula regardless of subject\n- *evaluate* (2): evaluate the product of second formula against the product of the first\n- *cell* (3): test if the product is a cell\n- *incr* (4): increment the product\n- *eq* (5): test for equality between nouns in the product\n\nAnd five additional formulas, reducible to the 6 above:\n\n```\n*[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]\n*[a 7 b c]       *[a 2 b 1 c]\n*[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]\n*[a 9 b c]       *[a 7 c 2 [0 1] 0 b]\n*[a 10 [b c] d]  *[a 8 c 7 [0 3] d]\n*[a 10 b c]      *[a c]\n```\n\n- *ife* (6): if/then/else\n- *compose* (7): evaluate formulas composed left-to-right\n- *extend* (8): evaluate the second formula against [product of first, subject]\n- *invoke* (9): construct a core and evaluate one of it's arms against it\n- *hint* (10): skip first formula, evaluate second\n\nFormulas are exported in the `nock.formulas` namespace:\n\n```js\nnock.nock(2, [8, [[4, [1, 1]], [0, 1]]])\n// [2, 2]\nnock.formulas.eq(2, [8, [[4, [1, 1]], [0, 1]]])\n// 0\n```\n\nAs in the case of `nock.operators`, formulas require both arguments to be present and valid nouns.\n\nFormulas 6-10 are implemented in two ways: directly by the interpreter, and as evaluated macro expansions:\n\n```js\nnock.formulas.extend(42, [[4, [0, 1]], [0, 1]])\n// [43, 42]\nnock.formulas.macroExtend(42, [[4, [0, 1]], [0, 1]])\n// [43, 42]\n```\n\nBy default, the direct implementations are used. To use the macro expansions instead:\n\n```js\nnock.useMacros()\nnock.nock(42, [8, [[4, [0, 1]], [0, 1]]])\n// [43, 42]\n```\n\n#### generating formulas\n\nHoon, the native language of Urbit, is also the language of [`dojo`](//urbit.org/docs/using/shell/), the Urbit shell. Hoon expressions are compiled into Nock formulas, which are interpreted.\n\n```\n~novlen-hanweb:dojo> 1\n1\n```\n\nHoon -> Nock compilation is a first class primitive in Hoon *([`:code` or `!=`](//urbit.org/docs/hoon/twig/zap-wild/tis-code/))*:\n\n```\n~novlen-hanweb:dojo> !=(1)\n[1 1]\n```\n\nas is the Nock formula itself *([`:nock` or `.*`](//urbit.org/docs/hoon/twig/dot-nock/tar-nock/))*:\n\n```\n~novlen-hanweb:dojo> .*(. [1 1])\n1\n~novlen-hanweb:dojo> .*(. !=(1))\n1\n```\n\nAs previously noted, `nock()` can evaluate formulas passed as strings:\n\n```js\nnock.nock('[1 1]')\n// => 1\n```\n\nFor convenience, convert your Nock formula to a string directly in `dojo` (technically, print your `noun` to a `tape`):\n\n```\n~novlen-hanweb:dojo> <!=(1)>\n\"[1 1]\"\n```\n\n#### generating `decrement`\n\nHoon provides a decrement function in it's standard library:\n\n```\n~novlen-hanweb:dojo> (dec 10)\n9\n```\n\nThe implemention for `dec` is in a [`core`](//urbit.org/docs/hoon/basic/#-core-p-span-q-map-term-span) - compiling it to Nock results in a formula that references that `core`, not a standalone decrement implementation:\n\n```\n~novlen-hanweb:dojo> !=((dec 10))\n[8 [9 24.834.031 0 31] 9 2 [0 4] [7 [0 3] 1 10] 0 11]\n```\n\nThere's probably a way to de-reference that `core` address *(`24.834.031`)* and compile the implementation - but I don't know it... Instead, we can evaluate the standard-library decrement implementation directly:\n\n```\n++  dec                                                 ::  decrement\n  ~/  %dec\n  |=  a/@\n  ~|  %decrement-underflow\n  ?<  =(0 a)\n  =+  b=0\n  |-  ^-  @\n  ?:  =(a +(b))  b\n  $(b +(b))\n```\n\n*from [urbit.org/docs/hoon/library/1a/#-dec](//urbit.org/docs/hoon/library/1a/#-dec)*\n\nConverting the linked implementation from [tall-form to flat-form](//urbit.org/docs/hoon/syntax/#-tall-and-flat-forms) (and removing the `hint` instructions) results in this expression:\n\n```\n|=(a/@ ?<(=(0 a) =+(b=0 |-(^-(@ ?:(=(a +(b)) b $(b +(b))))))))\n```\n\nwhich we can evaluate:\n\n```\n~novlen-hanweb:dojo> (|=(a/@ ?<(=(0 a) =+(b=0 |-(^-(@ ?:(=(a +(b)) b $(b +(b)))))))) 10)\n9\n```\n\ncompile to Nock (with `!=`):\n\n```\n~novlen-hanweb:dojo> !=((|=(a/@ ?<(=(0 a) =+(b=0 |-(^-(@ ?:(=(a +(b)) b $(b +(b)))))))) 10))\n[ 8\n  [8 [1 0] [1 6 [5 [1 0] 0 6] [0 0] 8 [1 0] 8 [1 6 [5 [0 30] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1] 0 1]\n  9\n  2\n  [0 4]\n  [7 [0 3] 1 10]\n  0\n  11\n]\n```\n\nevaluate the compiled Nock (with `.*`):\n\n```\n~novlen-hanweb:dojo> .*(~ !=((|=(a/@ ?<(=(0 a) =+(b=0 |-(^-(@ ?:(=(a +(b)) b $(b +(b)))))))) 10)))\n9\n```\n\nprint to a `tape` (with `<...>`):\n\n```\n~novlen-hanweb:dojo> <!=((|=(a/@ ?<(=(0 a) =+(b=0 |-(^-(@ ?:(=(a +(b)) b $(b +(b)))))))) 10))>\n\"[8 [8 [1 0] [1 6 [5 [1 0] 0 6] [0 0] 8 [1 0] 8 [1 6 [5 [0 30] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1] 0 1] 9 2 [0 4] [7 [0 3] 1 10] 0 11]\"\n```\n\nand, _**finally**_, evaluate in `nock.js`:\n\n```js\nnock.nock(\"[8 [8 [1 0] [1 6 [5 [1 0] 0 6] [0 0] 8 [1 0] 8 [1 6 [5 [0 30] 4 0 6] [0 6] 9 2 [0 2] [4 0 6] 0 7] 9 2 0 1] 0 1] 9 2 [0 4] [7 [0 3] 1 10] 0 11]\")\n// 9\n```\n\nTo get up and and running with an urbit, see [github.com/urbit/urbit](//github.com/urbit/urbit) and [urbit.org/docs/using/install/](//urbit.org/docs/using/install/).\n","created":"2016-04-26T17:48:41.440Z","modified":"2016-06-03T05:40:28.376Z","lastPublisher":{"name":"joemfb","email":"joemfb@gmail.com"},"owners":[{"name":"joemfb","email":"joemfb@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"nock.js","_nodeVersion":"4.0.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/nock.js-1.1.0.tgz_1464932426190_0.9898029032628983"},"_npmUser":{"name":"joemfb","email":"joemfb@gmail.com"},"_npmVersion":"2.14.2","_rev":"1-a79b665ceaf845f759696baf855c85e2","_shasum":"f15b349fb6e369122a741d8b2142cfd5b3f0f332","author":{"name":"joemfb"},"bugs":{"url":"https://github.com/joemfb/nock.js/issues"},"directories":{},"dist-tags":{"latest":"1.1.0"},"dist":{"shasum":"f15b349fb6e369122a741d8b2142cfd5b3f0f332","tarball":"http://registry.npmjs.org/nock.js/-/nock.js-1.1.0.tgz"},"maintainers":[{"name":"joemfb","email":"joemfb@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2016-06-03T05:40:28.376Z","created":"2016-04-26T17:48:41.440Z","1.0.0":"2016-04-26T17:48:41.440Z","1.0.1":"2016-05-03T04:36:23.983Z","1.0.2":"2016-05-03T04:55:04.627Z","1.1.0":"2016-06-03T05:40:28.376Z"}}}